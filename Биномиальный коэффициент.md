**Описание алгоритмов расчёта биномиального коэффициента C(n,k)** 

**Общие замечания**

Расчёт биномиального коэффициента – очень известная задача. По этой теме множество статей и обсуждений в интернете. Задача интересна тем, что при простой математической формулировке она требует очень много вычислений. Поэтому предложено много алгоритмов, улучшающих этот процесс.

Я реализовывала алгоритмы на C#. Реализация на Java должна быть очень похожей. По началу результат получала в типе UInt64. Потом оказалось, что и в C# и в Java имеется BigInteger, предназначенный для представления неограниченной длинны целых чисел. Внутренняя реализация отличается, но сам тип в обоих языках есть. Поэтому я все результаты привела к нему.

Сами алгоритмы

**1. «Наивный» алгоритм BinomNaive**

Просто расчёт по формуле 

![ C\_n^k = \frac{n!}{k! (n-k)!} ](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.001.png "c3c165b11abfcc9c21ae4b1bb7df43b2")

Работает медленнее других алгоритмов, кроме рекурсивного. Но на современном компьютере даже это работает неплохо.

**2. Улучшенный алгоритм BinomAdvanced**

– очевидные результаты для C(n,0) = C(n,n) = 1, C(n,1) = n возвращаются без расчётов;

– сокращены k! в числителе и знаменателе.

При сокращении учитывается правило симметрии:

![ C\_n^k = C\_n^{n-k} ](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.002.png "366347a902f6de3a2ce58cace1a68d71").

Выбирается большее значение из k, n-k, позволяющее сократить факториал подлиннее.

**3. Использование правила вынесения BinomFactorization**

Правило вынесения

![ C\_n^k = \frac{n}{k} C\_{n-1}^{k-1} ](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.003.png "b489d57e64375d2665bc809786e27543")

![](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.004.png) 

позволяет представить C(n,k) как произведение дробей. При этом правило гарантирует, что результат будет целым. Но здесь важна правильная последовательность операций: сначала умножение, потом деление. Если сначала вычислить дробь, результат может быть и нецелым, и дальнейшие вычисления будут некорректны.

Алгоритм достаточно хорош по быстродействию и не требует хранения данных. Все дельнейшие усовершенствования не привели к значимому улучшению времени счёта. 

Этот алгоритм реализован в двух вариантах: для BigInteger и для UInt64. В последнем случае возможен расчёт всех значений для n<=62, дальше наступает переполнение. Разницы во времени счёта при использовании разных типов данных не выявлено. Надо попробовать на более медленном компьютере.

**4. Рекурсивный алгоритм на основе сложения BinomRecursiveAdd**

Расчёт по известной рекуррентной формуле:

![ C\_n^k = C\_{n-1}^{k-1} + C\_{n-1}^k ](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.005.png "ea852aab5fda4c83b24f90a04474383e")

Самый худший из всех алгоритмов. Просто ужасно медленный расчёт. Жуть жуткая.

**5. Рекурсивный алгоритм на основе умножения BinomRecursiveMultiplay**

Опять использовано правило вынесения

![ C\_n^k = \frac{n}{k} C\_{n-1}^{k-1} ](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.003.png "b489d57e64375d2665bc809786e27543")

Количество рекурсивных вызовов значительно меньше и алгоритм вполне приемлем.

**6. Рекурсивный алгоритм на основе сложения с мемоизацией BinomRecursiveAddMemo**

Мемоизация (хранение промежуточных результатов во избежание повторного расчёта) дала неожиданно хорошие результаты. Я ожидала, что первый расчёт будет выполняться очень медленно, а остальные – быстро. Но даже первый расчёт выполнялся намного быстрее, чем в алгоритме № 4. В принципе, это логично. Треугольник Паскаля сужается кверху. При этом рекурсия ветвится тоже кверху, многократно заходя в одни и те же ячейки сужающегося треугольника. Получается, что верхние строки треугольника Паскаля используются для расчёта всех нижележащих значений и их сохранение существенно ускоряет расчёт.

Для мемоизации используется структура, представляющая собой коллекцию массивов. Массивы хранят строки треугольника Паскаля. При увеличении значения n создаётся массив под новую строку. Теоретически, такая структура позволяет хранить неограниченный объём данных. Точнее, ограничения сугубо физические, ни с алгоритмами, ни с математикой не связаны.

Поскольку треугольник Паскаля симметричный, можно хранить только половину значений, получая остальные на основе правила симметрии

![ C\_n^k = C\_n^{n-k} ](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.002.png "366347a902f6de3a2ce58cace1a68d71").

Кроме того, очевидные результаты: C(n,0) = 1, C(n,1) = n не требуют расчётов и тоже не сохраняются. Получается, что мы не храним первых 2 столбца и целиком верхние 3 строки. Это уменьшает объём данных, но усложняет работу с индексами (значения n и k не являются номерами строк и столбцов, надо пересчитывать, добавляя константы). Если честно, без этой заморочки можно было обойтись и перерасход памяти был бы несущественный.

Данные хранятся в оперативной памяти, на диск не сохраняются.

**7. Рекурсивный алгоритм на основе умножения с мемоизацией BinomRecursiveMultiplayMemo**

Вариант алгоритма № 5 с сохранением рассчитанных значений. Для мемоизации используется такая же структура, как и в алгоритме № 6 (коллекция другая, но устроена точно так же).

**8. Алгоритм на основе умножения с мемоизацией без рекурсии BinomMultiplayMemo**

Вариант алгоритма № 7. Рассчитанные данные сохраняются в такой же коллекции. Вместо рекурсии производится поиск в коллекции ранее рассчитанного значения или значения, которое не надо считать.

**Ошибки**


Ошибочных алгоритмов я не делала, т.к. тут надо догадываться, как ошибаются другие. Вместо этого могу описать свои ошибки.

**Неправильная последовательность операций**

Можно использовать такие инструкции, и всё будет нормально:

`  `res \*= i; res /= j; 

а вот это будет некорректно:

`  `res \*= (m + i) / i;

Сначала вычистится дробь, при этом будет отброшен хвост от деления, а потом будет выполнено умножение на некорректное значение. Вместо этого, в алгоритмах, использующих правило вынесения (алгоритмы № 3, 5, 7, 8), должна быть инструкция вида:

`  `res = (res \* (m + i)) / i;

Тогда сначала выполнится умножение, а потом деление сократится с чем-то ранее умноженным, и результат останется целым.

**Путаница с индексами массивов**

Индексы массивов и циклов – неисчерпаемое поле для ошибок. Конкретно в алгоритме № 8 я напутала с индексами при поиске значения в коллекции из-за решения не сохранять первых 2 столбца. Ищем какое-то ранее рассчитанное значение, двигаясь в направлении уменьшения индексов (по диагонали вверх в треугольнике Паскаля). Если значение не нашлось, берём значение С(n-k+1, 1), находящееся по диагонали на k+1 строк выше искомого. Но для дальнейших расчётов дробей нужны индексы этого числа в массиве. В массиве его нет. Поэтому надо ещё раз уменьшить индексы, имитируя поиск за границами массива в столбце -1. Естественно, как индексы эти значения использовать нельзя.

Вообще, алгоритмы относительно простые. При кодировании, конечно, можно напутать в чём угодно, но возможностей для небанальных алгоритмических ошибок не так уж много.

**Что осталось за бортом**

**Мемоизация со сложением без рекурсии**

Неплохо бы построить аналог алгоритма № 6, не использующий рекурсии. Это может быть интересно как чисто алгоритмическая задача. Но с практической точки зрения всё это начало терять смысл. Мемоизация в сочетании с рекурсией работает прекрасно. Устранение рекурсии не улучшит вычислительный процесс.

**Сохранение факториалов**

Цитирую отсюда:

[https://e-maxx.ru/algo/binomial_coeff]()

*Вычисление за O(1)*

*Наконец, в некоторых ситуациях оказывается выгодно предпосчитать заранее значения всех факториалов, с тем, чтобы впоследствии считать любой необходимый биномиальный коэффициент, производя лишь два деления. Это может быть выгодно …, когда память не позволяет предпосчитать весь треугольник Паскаля…*

**Использование формулы Стирлинга для факториалов**

**Использование логарифмов и экспонент вместо умножения.** 

Старый программистский приём ускорения умножения. 

![](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.006.png) 

Не помню названия формулы. Вот здесь, например (кстати, на Java):

[https://ngin.pro/it/293-binomialnyy-koefficient-kod-na-java.html]()

[https://ftp.myfreeproject.com/it/293-binomialnyy-koefficient-kod-na-java.html]() 

**Использование степеней простых чисел**

В Интернете гуляют различной степени доделанности алгоритмы, предполагающие разложение числителя и знаменателя на простые множители, сокращение степеней и перемножение того, что осталось. По сути, задача разбивается на 3:

\- поиск простых чисел;

\- разложение на множители;

\- собственно, расчёт.

**Асимптотический расчёт с помощью преобразования Фурье**

Ссылка:

[https://habr.com/ru/post/274729/]()

Не разбиралась. Знаю, что преобразование Фурье используется для ускорения умножения и там есть какие-то асимптотические формулы. Возможно, для очень сильно больших n это того стоит. 

**ТЕСТИРОВАНИЕ** 

**ТЕСТ 1. Расчёт всех значений n = 0...20 (первые 21 строка треугольника Паскаля)**

Во всех случаях получается:

n=000: 1 

n=001: 1 1 

n=002: 1 2 1 

n=003: 1 3 3 1 

n=004: 1 4 6 4 1 

n=005: 1 5 10 10 5 1 

n=006: 1 6 15 20 15 6 1 

n=007: 1 7 21 35 35 21 7 1 

n=008: 1 8 28 56 70 56 28 8 1 

n=009: 1 9 36 84 126 126 84 36 9 1 

n=010: 1 10 45 120 210 252 210 120 45 10 1 

n=011: 1 11 55 165 330 462 462 330 165 55 11 1 

n=012: 1 12 66 220 495 792 924 792 495 220 66 12 1 

n=013: 1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1 

n=014: 1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1 

n=015: 1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1 

n=016: 1 16 120 560 1820 4368 8008 11440 12870 11440 8008 4368 1820 560 120 16 1 

n=017: 1 17 136 680 2380 6188 12376 19448 24310 24310 19448 12376 6188 2380 680 136 17 1 

n=018: 1 18 153 816 3060 8568 18564 31824 43758 48620 43758 31824 18564 8568 3060 816 153 18 1 

n=019: 1 19 171 969 3876 11628 27132 50388 75582 92378 92378 75582 50388 27132 11628 3876 969 171 19 1 

n=020: 1 20 190 1140 4845 15504 38760 77520 125970 167960 184756 167960 125970 77520 38760 15504 4845 1140 190 20 1

Время счёта: 

|"Наивыный" алгоритм **BinomNaive**|0 h 0 m 0 s 21 ms|
| :- | :- |
|Улучшенный алгоритм **BinomAdvanced**|0 h 0 m 0 s 12 ms|
|Вынесение дробей **BinomFactorization**|0 h 0 m 0 s 11 ms|
|Рекурсия (сложение) **BinomRecursiveAdd**|0 h 0 m 0 s 64 ms|
|Рекурсия (умножение) **BinomRecursiveMultiplay**|0 h 0 m 0 s 12 ms|
|Рекурсия (сложение) с мемоизацией **BinomRecursiveAddMemo**|0 h 0 m 0 s 15 ms|
|Рекурсия (умножение) с мемоизацией **BinomRecursiveMultiplayMemo**|0 h 0 m 0 s 12 ms|
|Умножение дробей с мемоизацией без рекурсии **BinomMultiplayMemo**|0 h 0 m 0 s 13 ms|

**ТЕСТ 2. Расчёт значения C(10,5) = 252**

Во всех случаях время счёта в пределах 0…1 ms.

Количество рекурсивных вызовов:

|Рекурсия (сложение) **BinomRecursiveAdd**|1048564|
| :- | :- |
|Рекурсия (умножение) **BinomRecursiveMultiplay**|2024|
|Рекурсия (сложение) с мемоизацией **BinomRecursiveAddMemo**|394|
|Рекурсия (умножение) с мемоизацией **BinomRecursiveMultiplayMemo**|313|

**ТЕСТ 3. Расчёт значения C(30,15) без очистки мемо**

C(30,15) = 155117520

Для рекурсии со сложением **BinomRecursiveAdd:** 

0 h 0 m **4 s 25 ms**

Количество вызовов: 80233199

Для остальных алгоритмов время счёта 0…1 ms;

**ТЕСТ 4. Расчёт значения C(100,50) без очистки мемо**

C(100,50) = 100891344545564193334812497256

Для рекурсии со сложением **BinomRecursiveAdd:** 

время счёта – несколько часов (за 12 часов расчёт не был закончен)

Из дальнейших тестов этот алгоритм исключён.

Для остальных алгоритмов время счёта 0…1 ms;


**ТЕСТ 5. Расчёт значения C(62,31) с разными типами результата**

C(62,31) = 465428353255261088

Расчёт одним алгоритмом на основе произведения дробей **BinomFactorization**. Реализация с двумя типами данных: BigInteger, UInt64.

Разницы ни в результате, ни во времени счёта не выявлено.

**ТЕСТ 5. Расчёт 100 случайных значений, мемо очищались**

Генерируется 100 случайных целых чисел n в пределах 1…1000.

Выполняется расчёт C(n, n/2). Все алгоритмы работают с одним набором входных данных. Самый медленный рекурсивный алгоритм исключён. Перед тестом все коллекции мемо очищены.


|"Наивыный" алгоритм **BinomNaive**|133 ms|
| :- | :- |
|Улучшенный алгоритм **BinomAdvanced**|44 ms|
|Вынесение дробей **BinomFactorization**|16 ms|
|Рекурсия (умножение) **BinomRecursiveMultiplay**|28 ms|
|Рекурсия (сложение) с мемоизацией **BinomRecursiveAddMemo**|43 ms|
|Рекурсия (умножение) с мемоизацией **BinomRecursiveMultiplayMemo**|19 ms|
|Умножение дробей с мемоизацией без рекурсии **BinomMultiplayMemo**|34 ms|

Массивы мемо очищены, после чего выполнен полный предварительный расчёт: рассчитан треугольник Паскаля для всех n=1….1000. После этого повторно запущен тест для тех же исходных данных. Вопреки ожиданиям, предварительный расчёт не ускоряет прохождение теста (время считалось с учётом предварительного расчёта, который, видимо, всё время и занял).


|Рекурсия (сложение) с мемоизацией **BinomRecursiveAddMemo**|55 ms|
| :- | :- |
|Рекурсия (умножение) с мемоизацией **BinomRecursiveMultiplayMemo**|143 ms|
|Умножение дробей с мемоизацией без рекурсии **BinomMultiplayMemo**|136 ms|

Тест запущен повторно без очистки мемо. Тут всё ясно. Алгоритмы с мемоизацией становятся очень быстрыми

|Рекурсия (сложение) с мемоизацией **BinomRecursiveAddMemo**|0 ms|
| :- | :- |
|Рекурсия (умножение) с мемоизацией **BinomRecursiveMultiplayMemo**|0 ms|
|Умножение дробей с мемоизацией без рекурсии **BinomMultiplayMemo**|0 ms|

**Расход памяти**

Для языков с автоматическим управлением памятью расход памяти посчитать не так просто.

При выполнении тестов с мемоизацией для больших n память, выделенная процессу, возрастает с 2 МБ до 35 МБ:

![](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.007.png)

![](Aspose.Words.e72fad26-16ca-448c-a967-511cdcacbbea.008.png)

Надо учитывать, что таких алгоритмов 3 и у каждого из них своя коллекция.





